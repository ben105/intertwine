#!/usr/bin/env python2.7

from flask import Flask, request
import json
import re
import sys
import os
import psycopg2

from intertwine.friends import friends
from intertwine.accounts import register
from intertwine.accounts import search
from intertwine.accounts import accounts
from intertwine.activity import events
from intertwine.activity import comments
from intertwine.activity import activity
from intertwine import push
from intertwine import log_manager
from intertwine import context


log_manager.EnableLogging()

app = Flask(__name__)

db_server = 'intertwine.cntms98hv39g.us-west-2.rds.amazonaws.com'
conn = None
try:
	conn = psycopg2.connect("dbname=intertwine host=%s user=intertwine password=intertwine" % db_server)
except Exception as exc:
	logging.error('exception raised trying to connect to database\n%s', str(exc))
	quit()

def context(request):
	ctx = context.SecurityContext(request, conn.cursor())
	ctx.first = first
	ctx.last = last
	return ctx


####### Comments ########

@app.route('/api/v1/comment/<int:event_id>', methods=['GET'])
def comment_get(event_id):
	ctx = context(request)
	resp = comments.get_comments(ctx, event_id)
	return json.dumps(resp)

@app.route('/api/v1/comment', methods=['POST'])
def comment_handler():
	ctx = context(request)
	# Get all the information from the POST body.
	body = json.loads(request.data)
	comment = body["comment"]
	event_id = body["event_id"]
	title = body["title"]
	resp = comments.comment(ctx, event_id, title, comment)
	return json.dumps(resp)



####### Activities ########

@app.route('/api/v1/activity', methods=['GET'])
def activities():
	ctx = context(request)
	resp = activity.get_activity(ctx)
	return json.dumps(resp)

@app.route('/api/v1/events', methods=['GET', 'POST', 'DELETE'])
def event_api():
	ctx = context(request)

	# If user is asking for their activities.
	if request.method == "GET":
		resp = events.get_events(ctx)

	# Or if the user is creating an activity.
	elif request.method == "POST":
		body = json.loads(request.data)
		first = body.get('first')
		last = body.get('last')
		title = body.get('title')
		friends = body.get('friends')
		desc = body.get('description')
		resp = events.create(ctx, title, desc, friends)

	# Or if the user is deleting an activity.
	elif request.method == "DELETE":
		body = json.loads(request.data)
		event_id = body.get('event_id')
		resp = events.delete(ctx, event_id)

	return json.dumps(resp)



####### Device Token ########

@app.route('/api/v1/device_token', methods=['POST'])
def set_device_token():
	ctx = context(request)
	token_data = request.data
	return devices.add(token_data)



####### Searching ########

@app.route('/api/v1/search/<name>', methods=['GET'])
def search(name):
	ctx = context(request)
	resp = search.find(ctx, name)
	return json.dumps(resp)



####### Signing In ########

@app.route('/api/v1/signin', methods=['POST'])
def sign_in():
	"""This sign-in API should be used for accounts
	that are attempting to sign in with an email address.
	A Post form is required with this request.

	Keyword arguments:
	email -- the email address of the user signing in
	password -- the password associated with the email's account

	The success of this request will result in a JSON dictionary
	posed as {'success':'true'}

	The failure of this request will result in a JSON dictionary
	posed as {'error':'Invalid login credentials'}
	"""
	ctx = context(request)
	email = request.form.get('email')
	password = request.form.get('password')
	result = accounts.sign_in_email(ctx, email, password)
	return json.dumps(result)

@app.route('/api/v1/adduser', methods=['POST'])
def add_user():
	ctx = context(request)
	# Errors dict to store all errors
	errors = dict()
	# Extract the POST data
	first = request.form.get('first')
	last = request.form.get('last')
	email = request.form.get('email')
	facebook_id = request.form.get('facebook_id')
	password = request.form.get('password')
	account_type = request.form.get('account_type')
	# Let' validate the content the user has entered
	if account_type == "email":
		err = register.invalid_name(first)
		if err:
			errors['first'] = err
		err = register.invalid_name(last)
		if err:
			errors['last'] = err
		err = register.invalid_password(password)
		if err:
			errors['password'] = err
		err = register.invalid_email(email)
		if err:
			errors['email'] = err
	# Make a connection to the postgres database
	try:
		conn = psycopg2.connect("dbname=intertwine host=localhost user=intertwine password=intertwine")
		cur = conn.cur()
		cur.connection.autocommit = True
	except:
		errors['connection'] = 'Connection issues on the seregisterer'
		return errors
	# Check if there is already an account with this email
	if account_type == "email":
		err = register.duplicate_email(cur, email)
		if err:
			errors['email'] = err
	# Now that we've done some validation, we can
	# send back the error dictionary if it has any
	# values.
	if len(errors.keys()):
		return json.dumps(errors)	
	# If we don't have any errors, then we can 
	# continue.
	# Create the account.
	if account_type == "email":
		err = accounts.create_account_email(cur, email=email, first=first, last=last, password=password)
		if err:
			errors['connection'] = err
			return errors
	elif account_type == "facebook":
		result = accounts.sign_in_facebook(cur, facebook_id, first, last)
		return json.dumps(result)
	else:
		return json.dumps( {"error":"Incorrect account type."} )
	# Succesfully created an account
	#cur.connection.close()
	return json.dumps( {"success":"true"} )



####### Friend Requests ########

@app.route('/api/v1/friend_requests', methods=['POST', 'GET'])
def friendrequests():
	"""Friend request can either be a get
	or a post. A get will simply return
	the results of all pending friend 
	requests, while a post will initiate
	a friend request.
	"""
	ctx = context(request)
	data = []
	if request.method == "GET":
		data = friends.get_pending_requests(ctx)
	elif request.method == "POST":
		requester_id = int(request.headers.get('user_id'))
		requestee_id = int(request.form.get('friend_id'))
		data = friends.send_request(ctx, requestee_id)
	return json.dumps(data)


@app.route('/api/v1/friends', methods=['POST'])
def get_friends():
	ctx = context(request)
	data = friends.get_friends(ctx)
	return json.dumps(data)

@app.route('/api/v1/friend_decline', methods=['POST'])
def deny():
	"""This API endpoint will either get the list
	of denied friends, with the GET method, or 
	deny a friend request with the POST method.
	"""
	ctx = context(request)
	friend_id = request.form.get('friend_id')
	resp = friends.accept_request(ctx, friend_id)
	return json.dumps(resp)

@app.route('/api/v1/send_friend_request', methods=['POST'])
def send_request():
	ctx = context(request)
	friend_id = int(request.form.get('friend_id'))
	data = friends.send_request(ctx, friend_id)
	return json.dumps(data)

@app.route('/api/v1/friend_accept', methods=['POST'])
def friend_accept():
	ctx = context(request)
	friend_id = request.form.get('friend_id')
	data = friends.accept_request(ctx, friend_id)
	# push.push_notification(cur, friend_id, "%d has accepted your friend request." % str(user_id))
	return json.dumps(data)

@app.route('/api/v1/facebook_friends', methods=['POST'])
def facebook_friends():
	ctx = context(request)
	facebook_friends = json.loads(request.data)
	data = friends.fb_friends(ctx, facebook_friends)
	return json.dumps(data)


if __name__ == "__main__":
	app.run(host='0.0.0.0')


